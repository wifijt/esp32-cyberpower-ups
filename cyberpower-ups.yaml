substitutions:
  name: "cyberpower-ups"
  friendly_name: "CyberPower UPS"
  battery_wh: "155.0" # real world effective WH of the UPS to align estimated runtime

esphome:
  name: ${name}
  friendly_name: ${friendly_name}

# FIXED: Platform moved to its own block
esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# FIXED: Explicitly use Git source
external_components:
  - source:
      type: git
      url: https://github.com/wifijt/esp32-cyberpower-ups
    components: [ cyberpower_ups ]

# Initialize the UPS Driver
cyberpower_ups:
  id: ups_device

# Expose the sensors
sensor:
  - platform: cyberpower_ups
    watts:
      name: "${friendly_name} Output Watts"
      id: ups_watts
    va:
      name: "${friendly_name} Output VA"
    load:
      name: "${friendly_name} Load"
    battery:
      name: "${friendly_name} Battery"
      id: ups_batt_pct
      
  - platform: template
    name: "${friendly_name} Estimated Runtime"
    unit_of_measurement: "min"
    device_class: duration
    icon: "mdi:timer-outline"
    # Math: (Battery Watt-Hours * 0.8 efficiency / Current Watts) * 60 minutes 
    lambda: |-
      float current_watts = id(ups_watts).state; 
      float pct = id(ups_batt_pct).state / 100.0f; // Convert 0-100 to 0.0-1.0
      if (current_watts > 5.0) {
        float wh = ${battery_wh};
        float minutes = (wh * 0.8f * pct / current_watts) * 60.0f;
        return std::min(minutes, 480.0f); // Cap at 8 hours for display 
      } else {
        return 480.0f; 
      }
    update_interval: 10s

binary_sensor:
  - platform: cyberpower_ups
    online_status:
      name: "${friendly_name} Power Status"
      id: power_status
text_sensor:
  # This converts the binary 'online' status into friendly text
  - platform: template
    name: "${friendly_name} Status"
    id: ups_status_text
    icon: "mdi:power-settings"
    lambda: |-
      if (id(power_status).state) {
        return {"Mains (AC)"};
      } else {
        return {"Battery Backup"};
      }
    update_interval: 5s
